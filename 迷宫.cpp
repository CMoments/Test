#include<bits/stdc++.h>
using namespace std;
#define maxn 2000

string maze[maxn]= {
	"01010101001011001001010110010110100100001000101010",
	"00001000100000101010010000100000001001100110100101",
	"01111011010010001000001101001011100011000000010000",
	"01000000001010100011010000101000001010101011001011",
	"00011111000000101000010010100010100000101100000000",
	"11001000110101000010101100011010011010101011110111",
	"00011011010101001001001010000001000101001110000000",
	"10100000101000100110101010111110011000010000111010",
	"00111000001010100001100010000001000101001100001001",
	"11000110100001110010001001010101010101010001101000",
	"00010000100100000101001010101110100010101010000101",
	"11100100101001001000010000010101010100100100010100",
	"00000010000000101011001111010001100000101010100011",
	"10101010011100001000011000010110011110110100001000",
	"10101010100001101010100101000010100000111011101001",
	"10000000101100010000101100101101001011100000000100",
	"10101001000000010100100001000100000100011110101001",
	"00101001010101101001010100011010101101110000110101",
	"11001010000100001100000010100101000001000111000010",
	"00001000110000110101101000000100101001001000011101",
	"10100101000101000000001110110010110101101010100001",
	"00101000010000110101010000100010001001000100010101",
	"10100001000110010001000010101001010101011111010010",
	"00000100101000000110010100101001000001000000000010",
	"11010000001001110111001001000011101001011011101000",
	"00000110100010001000100000001000011101000000110011",
	"10101000101000100010001111100010101001010000001000",
	"10000010100101001010110000000100101010001011101000",
	"00111100001000010000000110111000000001000000001011",
	"10000001100111010111010001000110111010101101111000"};
bool vis[maxn][maxn];//标记
int dir[4][2]={{1,0},{0,-1},{0,1},{-1,0}};//D L R U

bool in(int x,int y)
{
	return x<30&&x>=0&&y>=0&&y<50;
}

struct node
{
	int x,y,d;
	char pos;//存储D L R U
};

node father[maxn][maxn];//当前节点的父节点
node now,nex;//指向当前和下一个位置

void dfs(int x,int y)//递归打印
{
	if(x==0&&y==0)//找到起点开始正向打印路径
		return;
	else
		dfs(father[x][y].x,father[x][y].y);
	
	cout<<father[x][y].pos;
}

void bfs(int x,int y)
{
	queue<node> q;
	
	now.x=x;
	now.y=y;
	now.d=0;
	q.push(now);
	
	vis[x][y]=true;
	while(!q.empty())
	{
		now=q.front();
		q.pop();
		for(int i=0;i<4;i++)//走下左右上按字典序的四个方向
		{
			int tx=now.x+dir[i][0];
			int ty=now.y+dir[i][1];
			if(in(tx,ty)&&!vis[tx][ty]&&maze[tx][ty]!='1')//判断是否超出范围，是否用过，是否为1
			{
				vis[tx][ty]=true;//标记为用过
				
				nex.x=tx;
				nex.y=ty;
				nex.d=now.d+1;
				q.push(nex);//压入队列
				
				father[tx][ty].x=now.x;//存储父节点坐标
				father[tx][ty].y=now.y;
				if(i==0)//存储路径
					father[tx][ty].pos='D';
				else if(i==1)
					father[tx][ty].pos='L';
				else if(i==2)
					father[tx][ty].pos='R';
				else if(i==3)
					father[tx][ty].pos='U';
				
				
			}
		}
	}
}

int main()
{
	
	bfs(0,0);
	dfs(29,49);//打印路径
	
	return 0;
}
