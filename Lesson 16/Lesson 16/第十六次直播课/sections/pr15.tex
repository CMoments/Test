\section{小蓝找答案}

\begin{frame}{Solution}

非常麻烦的构造。

假设我们知道答案为 $p$，此时我们想要去构造序列。若 $a_i>a_{i-1}$，此时我们只需要在后面添加 $a_i-a_{i-1}$ 个 a 即可；否则，等价于将上一个字符串后面 $a_{i-1}-a_i$ 个都删掉，然后让第 $a_{i}$ 个字符加一。若加一后大于 a+$p$，则让它变成 a，让 $a_i-1$ 个字符加一...直到加个不大于 a+$p$，或者加无可加了。加无可加是不合法情况。

注意到 $p$ 具有二分性，我们考虑二分答案。但问题在于维护上面那个过程。由于 $a_i$ 很大，好像不太好维护。怎么办呢？

一个很好的想法是，我们直接维护当前字符串还可以加多少次。每次加上新的长度等价于乘幂次，减去等价于整除幂次。好像很不错？但 $a_i$ 太大，高精度都无法维护。

\end{frame}
\begin{frame}{Solution}

注意到实际上等价于维护 $p$ 进制数，我们考虑惰性维护。什么意思呢？对于插入 $a_i-a_{i-1}$ 个 a 而言，我们不去立刻插入 $a_i-a_{i-1}$ 个 a，而是只插入一个二元组 $(a_i,0)$，表示我们在 $a_i$ 处插入了一个 a。这样的话，我们只需要维护二元组，每次加一的过程等价于让第二维加一。当第二维 $=p$ 时，我们去掉 $(a_i,p)$，加入 $(a_{i-1},1)$，再加入 $(a_i,0)$。而删除操作更是等价于去除所有大于某个位置的二元组们。

具体来说，我们定义操作 $\mathrm{push}(x)$ 为使 $a_x$ 处字符加一。用一个单调栈结构维护二元组 $(u,v)$，表示 $u$ 处的字符为 a+$v$；结构中没出现的位置会被认为这个位置的字符为 a。我们只会在 $a_i\leq a_{i-1}$ 时用到，即 $a_i\leq a_{i-1}$，我们执行一次 $\mathrm{push}(a_i)$。对于 $\mathrm{push}(x)$ 而言，我们先弹出所有满足 $(u,v), u>x$ 的二元组。然后若不存在 $(x,v)$ 二元组，则加入 $(x,0)$；否则让 $(x,v)\leftarrow (x,v+1)$；若此时 $v+1=p$，则执行弹出 $(x,v+1)$，并执行 $\mathrm{push}(x-1)$，再加入 $(x,0)$。

\end{frame}
\begin{frame}{Solution}

考虑时间复杂度。这是很经典的计数器。弹出操作和弹入操作数一致，我们只用分析弹入的操作数。注意到弹入一个二元组，如果是直接弹入的，最多 $\mathcal O(n)$ 次；如果是间接弹入的，我们考虑一个时间复杂度显然大于等于该问题的问题。

有一个若干位的二进制数，每次修改一位的代价是 $\mathcal O(1)$，现加 $n$ 次 $2$ 的幂次，问修改的总代价。

注意到带来额外代价的操作是进位。而进位一次需要之前的一次铺垫。很容易发现，一次进位至少需要一次铺垫。这意味着进位的次数也是 $\mathcal O(n)$ 的。所以修改的总代价就是 $\mathcal O(n)$。(实际上存在一种更为合适的分析手段，感兴趣可以了解势能分析法)

回到这道题，于是总时间复杂度就是 $\mathcal O(n\log n)$ 了。$\log n$ 来自于二分。

\end{frame}